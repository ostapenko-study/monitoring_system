#include "MainStat.h"
#include <QProcess>

//generated by chatgpt start

QJsonObject ProcessMainInfo::toJson() const
{
    QJsonObject obj;
    obj["pid"] = pid;
    obj["user"] = user;
    obj["pr"] = pr;
    obj["ni"] = ni;
    obj["virt"] = virt;
    obj["res"] = res;
    obj["shr"] = shr;
    obj["state"] = state;
    obj["cpu"] = cpuUsage;
    obj["mem"] = memUsage;
    obj["time"] = time;
    obj["command"] = command;
    return obj;
}

namespace {

/*
    Формат поля TIME+ у виводі команди top зазвичай має вигляд:
    HH:MM.SS
    або MM:SS
    або іноді 0:00.12 (тобто хвилини:секунди.соті секунди)
*/
qint64 parseTimeToSeconds(const QString& timeStr) {
    QStringList parts = timeStr.split(QRegularExpression("[:.+]"));
    if (parts.size() == 2) {
        // MM:SS
        bool ok1, ok2;
        int minutes = parts[0].toInt(&ok1);
        int seconds = parts[1].toInt(&ok2);
        return (ok1 && ok2) ? (minutes * 60 + seconds) : 0;
    } else if (parts.size() == 3) {
        // HH:MM:SS or MM:SS.xx
        if(timeStr.contains(".")){
            bool ok1, ok2;
            int m = parts[0].toInt(&ok1);
            int s = parts[1].toInt(&ok2);
            return (ok1 && ok2) ? (m * 60 + s) : 0;
        }else{
            bool ok1, ok2, ok3;
            int h = parts[0].toInt(&ok1);
            int m = parts[1].toInt(&ok2);
            int s = parts[2].toInt(&ok3);
            return (ok1 && ok2 && ok3) ? (h * 3600 + m * 60 + s) : 0;
        }
    } else if (parts.size() == 4) {
        // HH:MM:SS.xx
        bool ok1, ok2, ok3;
        int h = parts[0].toInt(&ok1);
        int m = parts[1].toInt(&ok2);
        int s = parts[2].toInt(&ok3);
        return (ok1 && ok2 && ok3) ? (h * 3600 + m * 60 + s) : 0;
    }
    return 0;
}
/*
    Причина використання remove(QRegularExpression("[^\d.]")): top може показувати розмір з одиницями (K, M, G, тощо),
    а стандартний toDouble() не вміє автоматично парсити рядки типу "23.5m" — він вважає це невалідним числом.
*/
double parseSizeField(const QString& s) {
    QRegularExpression rx(R"(([\d\.]+)([kKmMgG]?))");
    QRegularExpressionMatch match = rx.match(s.trimmed());
    if (!match.hasMatch()) return 0.0;

    double value = match.captured(1).toDouble();
    QString unit = match.captured(2).toLower();

    if (unit == "k") return value * 1024;
    if (unit == "m") return value * 1024 * 1024;
    if (unit == "g") return value * 1024 * 1024 * 1024;
    return value;
}

} // anonymous namespace

ProcessMainInfo ProcessMainInfo::fromTopLine(const QString &line)
{
    QStringList parts = line.split(QRegularExpression("\\s+"));
    if(parts.size() < 12){
        qWarning() << "parse error";
        return {};
    }

    ProcessMainInfo p;
    p.pid = parts[0].toInt();
    p.user = parts[1];
    p.pr = parts[2].toDouble();
    p.ni = parts[3].toDouble();
    p.virt = parseSizeField(parts[4]);
    p.res  = parseSizeField(parts[5]);
    p.shr  = parseSizeField(parts[6]);
    p.state = parts[7].at(0).toLatin1();
    p.cpuUsage = parts[8].toDouble();
    p.memUsage = parts[9].toDouble();
    p.time = parts[10];
    p.timeInSecs = parseTimeToSeconds(p.time);
    p.command = parts.mid(11).join(" ");

    return p;
}

ProcessMainInfo ProcessMainInfo::fromPsLine(const QString &line)
{
    QStringList parts = line.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);

    // Перевірка кількості полів
    if (parts.size() < 12) {
        qWarning() << "Недостатньо полів у рядку:" << line;
        return {};
    }

    ProcessMainInfo info;
    bool ok = false;

    info.pid = parts[0].toInt(&ok);
    if (!ok) return {};

    info.ni = parts[2].toDouble();
    info.pr = parts[3].toDouble();

    QString statStr = parts[4];
    if (!statStr.isEmpty())
        info.state = statStr[0].toLatin1();

    info.cpuUsage = parts[5].toDouble();
    info.memUsage = parts[6].toDouble();
    info.virt = parts[7].toDouble();
    info.res = parts[8].toDouble();

    info.time = parts[9];  // etime (наприклад, 00:01:32)
    info.timeInSecs = parseTimeToSeconds(info.time);
    info.user = parts[10];

    // Команда може містити пробіли, тому з'єднуємо залишок
    info.command = parts.mid(11).join(" ");
    return info;
}

QVector<ProcessMainInfo> getProcessTopInfos()
{
    QProcess topProcess;
    topProcess.start("top", {"-b", "-n", "1"});

    if (!topProcess.waitForFinished(3000)) {
        qWarning() << "long answer by processing \"top\" command";
        return {};
    }

    return parseTopOutput(topProcess.readAllStandardOutput());
}

//generated by chatgpt end


QVector<ProcessMainInfo> getProcessTopInfosBySsh(const SshCredentials& ssh_credentials)
{
    return parseTopOutput(run_ssh(ssh_credentials, "top -b -n 1 -w 512"));
}

QVector<ProcessMainInfo> parseTopOutput(const QString &output)
{
    QVector<ProcessMainInfo> processes;
    const QStringList lines = output.split('\n', Qt::SkipEmptyParts);

    bool processSection = false;

    for (const QString& line : lines) {
        QString trimmed = line.trimmed();
        if (trimmed.startsWith("PID")) {
            processSection = true;
            continue;
        }

        if (processSection) {
            auto info = ProcessMainInfo::fromTopLine(trimmed);
            if(info.pid == -1){
                qWarning() << "parse error handle";
                continue;
            }
            processes.append(std::move(info));
        }
    }

    return processes;
}

QVector<ProcessMainInfo> getProcessPsInfos()
{
    QProcess topProcess;
    topProcess.start("ps", {"-eo", "pid,ppid,ni,pri,stat,%cpu,%mem,vsz,rss,etime,user,cmd", "--sort=+pid"});

    if (!topProcess.waitForFinished(3000)) {
        qWarning() << "long answer by processing \"ps\" command";
        return {};
    }

    return parsePsOutput(topProcess.readAllStandardOutput());
}

QVector<ProcessMainInfo> getProcessPsInfosBySsh(const SshCredentials &ssh_credentials)
{
    return parsePsOutput(run_ssh(ssh_credentials, "ps -eo pid,ppid,ni,pri,stat,%cpu,%mem,vsz,rss,etime,user,cmd --sort=+pid "));
}

QVector<ProcessMainInfo> parsePsOutput(const QString &output)
{
    QVector<ProcessMainInfo> processes;
    const QStringList lines = output.split('\n', Qt::SkipEmptyParts);


    bool processSection = false;

    for (const QString& line : lines) {
        QString trimmed = line.trimmed();
        if (trimmed.startsWith("PID")) {
            processSection = true;
            continue;
        }

        if (processSection) {
            auto info = ProcessMainInfo::fromPsLine(trimmed);
            if(info.pid == -1){
                qWarning() << "parse error handle";
                continue;
            }
            processes.append(std::move(info));
        }
    }

    return processes;
}
